\section{\emph{rag}, a Ruby Autograder for ESaaS}


Having chosen Ruby and Rails for their excellent testing and
code-grooming tools, our approach was to repurpose those same tools into
autograders that would give finer-grained feedback than human graders
using more detailed tests, and would be easier to repurpose than
those built for other languages.

\subsection{Rubric Files}

autograder, rubric file - schematic diagram

current refactoring to allow rubric files to be pulled on demand and
updated in place

\subsection{RSpecGrader}

\texttt{rag}\uf{github.com/saasbook/rag} 
is actually a collection of three different autograding
``engines'' based on three open source testing
tools.  The first of these is
RSpec, a unit-testing and
BDD/TDD framework descended from XUnit, but which exploits Ruby's
flexible syntax to embed a unit-testing DSL in Ruby that results in very
readable tests.  

\tbd{describe RSpecGrader, coverage, how to assign points to subparts,
how we can check internal structure of code/whether students used correct
abstractions, etc; maybe include snippet from an existing spec}

\begin{figure}
  \centering
    \lstinputlisting[tabsize=1,basicstyle=\scriptsize\ttfamily]{figs/rspec_grader_rubric.rb}
  \caption{\label{fig:rspec-grader-rubric}
    Example of an RSpec grader rubric
  }
\end{figure}


\subsection{FeatureGrader}

One of our assignments requires students to write integration-level
tests using Cucumber, which allows such tests to be formulated in
stylized plain text, as Figure~\ref{fig:cucumber} shows.

 Cucumber allows
integration-level tests or user stories~\cite{user-stories} to be
expressed in plain prose, using regular expressions to match each step
of such a test to a block of code that sets up preconditions (\texttt{Given}), stimulates
the system (\texttt{When}), or checks postconditions (\texttt{Then}) as
appropriate; our code blocks are in Ruby, but the Cucumber framework
itself is language-agnostic.  


Our autograder for this
style of assignment is inspired by mutation testing, a technique invented
by George Amman and Jeff 
Offutt~\cite{ammann-offutt-sw-testing} in which a
testing tool pseudo-randomly mutates the program under test to ensure
that some test fails as a result of these introduced errors.

%% Since a SaaS application is being tested, black-box integration tests
%% must stimulate the SaaS application in the same way that
%% a human being user a Web browser would.
%% Depending on the testing environment, Cucumber can do this in one of
%% three ways.  The first uses a built-in browser simulator that hooks
%% directly into 
%% the Rails application server, and thus can only be used
%% with application stacks that use this server and that do not rely on
%% JavaScript.  The second is using Webdriver (formerly 
%% Selenium) to control a real browser via a now-standard remote-control
%% API (cite Webremote).  The third, which we use, uses a Ruby library called
%% Mechanize\footnote{Based on the Perl library of the same name.} to
%% direct requests to an application deployed on  a remote server.  

The FeatureGrader operates by working with an existing application that the student 
created tests will be applied to.   The application is modified so that the FeatureGrader
can adjust its behaviour by manipulating certain environment variables. Each of the scenarios 
required by the assignment are first tested against the working application.  Assuming the 
students have created the correct acceptance tests in Cucumber then all these tests should pass.  

Next the FeatureGrader starts to mutate the underlying application according to the a specification
such as the YAML file as shown in Figure~\ref{fig:featuregrader}, running the specified feature against
a different version of the application and checks that the specified scenarios do fail.  Students 
lose points according to the weights associated with the particular features that do not generate the correct
sort of failure.

\begin{figure}
  \begin{minipage}{0.45\textwidth}%
    \lstinputlisting{figs/cucumber_example.feature}%
  \end{minipage}%
  \begin{minipage}{0.5\textwidth}%
    \lstinputlisting[language=Ruby]{figs/cucumber_step_def_example.rb}%
  \end{minipage}%
  \caption{\label{fig:cucumber} Cucumber accepts integration tests 
    written in stylized prose (left) and uses regular expressions to map each
    step to a \emph{step definition} that sets up preconditions, exercises the app,
    or checks postconditions.  Step definitions 
    can stimulate a full-stack GUI-based web application in various
    ways, including remote-controlling a real browser with Webdriver
    (formerly Selenium) or using the Ruby Mechanize library to interact
    with a remote site.}
\end{figure}



\begin{figure}
  \begin{minipage}{0.45\textwidth}%
  \includegraphics[width=\textwidth]{figs/feature_grader.pdf}%
  \end{minipage}%
  \begin{minipage}{0.55\textwidth}%
  \lstinputlisting{figs/feature_grader_example.yml}%
  \end{minipage}
  \caption{\label{fig:featuregrader}%
FeatureGrader workflow and example YAML file.  In this case if Step1-1 passes,
Step1-3 will be run next.  Earlier steps must be less restrictive than
later steps (if the earlier step fails, there should be no way that a later one could pass).
\texttt{failures} are the two student-provided Cucumber scenarios that \emph{should fail} when
run because of mutations (bugs) inserted in the app.
}
\end{figure}

\subsection{MechanizeGrader}

Surveys of recent
autograders~\cite{ihantola-2010-autograding-survey,douce-2005-autograding-survey} mentioned as
a ``future direction'' a grader that can assess full-stack or GUI apps.


Capybara~\uf{jnicklas.github.io/capybara}
provides a Ruby-embedded DSL for interacting with Web-based
applications.
One can trigger actions on a web page such as filling in form fields
or clicking a button, and use XPath~\cite{xpath} to examine the
response page delivered by the server.
Capybara actions can either run in the same process as the app being
tested, or when used in conjunction with the Mechanize
library~\footnote{\url{https://rubygems.org/gems/mechanize}; based on
  the older Perl library of the same name.}, can trigger these actions
against a remote application, allowing black-box testing.



Our MechanizeGrader achieves this by combining Capybara's embedded DSL
for interacting with a Web application with the Mechanize HTTP library
for interacting with and scraping a remote site.

\tbd{SJ: explain brefly how it works and how it's configured, how tests
  external app given just a URI, etc}

\tbd{cite AWAT as another example of GUI grader}


\begin{figure}
  \input{figs/grader_summary}
  \caption{\label{fig:grader_summary} Summary of the autograder
    engines based on our repurposing of excellent existing open-source
    tools and testing techniques.  Only the RSpecGrader is
    Ruby-specific; the others are easily retargetable to other languages
    and systems.}
\end{figure}


